# pop.awk - Creates a skeleton insert statement based upon
#           a table description.
#
# Version 1.0.0.........Created
# Version 1.0.1.........Trunc dates for consistent results.
# Version 1.0.2.........Be a bit more understanding of format
#                       Introduce basic support for RAWs, BLOBs, CLOBs,
#                       NCLOBs and BFILEs. 
# Version 1.0.3.........Add basic support for TIMESTAMP.
#
# Usage and Restrictions:
#  See http://dlsunuk2.uk.oracle.com/Utils.html#pop
#
# Improvements:
#   o Handle long and other "more complex" datatypes better
#   o have a null bitmask.Eg YNYNYYYYNNNN etc so that we generate NULL
#   o handle scale/precision : eg number(7,2)
#
function getsize(str)
{
 #if (str !~ "\(" ) return 0;   # Wow - I'm really dumb
 if (!index(str, "(")) return 0;
 _str = str;
 gsub(","," ", _str);
 #gsub("("," ", _str);gsub(")"," ", _str);
 _cnt = split(_str, _one,"("); # I'm too dumb so let's do it the hard way
 #if (_cnt==0) return 0;           # Shouldn't happen but let's just ignore it
 split(_one[2], _two, ")"); 
 _cnt = split(_two[1],_three, " ");
 # Number(p,s)
 Gbase_type = _one[1];
 Gbase_prec = _three[1];
 Gbase_scale= _three[2]; 
 return Gbase_prec;
}
##########################################################################
BEGIN				{ version = "1.0.3";
				  loopvar = "i";    # Name of PLSQL loop var
				  pad     = "N";    # y/n flag if char padding
				  padchar = "*";    # what to pad with 
				  commit_cnt = 100; # How often to commit
				  maxlen = 200;	    # max cmdline length
				  truncflg = 1;     # Truncate dates ?
# The next two lines are used to blindly initialise some of the new Oracle8
# datatypes. I haven't made things too complicated here and it's envisaged
# that if this is not good enough (Eg, the value used for a BLOB is too long)
# then the user will amend this script.
bfile_name = "bfilename('POP_AWK_DIR', 'null')";
hexstr = "'0123456789ABCDEF'";# for use with raw datatypes
err1 = "Error: No columns found. Check Format of Input File!!";

printf("Rem Generated by pop.awk Version %s\n", version);
printf("Rem Options:\n");
printf("Rem  Loopvar=%s, padding=%s, padchar=%s, truncflg=%d\n", 
		loopvar, pad, padchar, truncflg);
printf("set echo on\n\n");
printf("Rem Uncomment the following line if BFILEs are used\n");
printf("Rem create or replace directory pop_awk_dir as '/dev';\n\n");
printf("begin\n");
printf(" for %s in 1 .. 5000 loop\n", loopvar);

midcnt=7;
midln[0] = "  if (mod(" loopvar "," commit_cnt ") = 0) then";
midln[1] = "     commit;";
midln[2] = "  end if;";
midln[3] = " end loop;";
midln[4] = " commit;";
midln[5] = "end;";
midln[6] = "/";
				}

/desc/ || /DESC/	{ cmd=$1; cmd=toupper(cmd);
			  if (cmd ~ "SVRMGR>" || cmd ~ "SVRMGRL>" ||
			      cmd ~ "SQL>")
			   {
			    tname = $NF; 
			    start=1;
			    ccount=0;
			    next;
			   }
			}

start != 1			{ next }

/Name *Null. *Type/		{ next }
/^ *--*/			{ next }
/^ *$/				{ next }

		{ colname[++ccount]=$1; 
                  type[ccount]=toupper($NF); 
		  #printf("* Column %s type %s\n",colname[ccount],type[ccount]);
                  next }

END		{ if (!ccount)
		   {
		    printf("%s\n", err1);
		    exit;
	           }
		  printf("-- Col Cnt = %d\n", ccount);
		  printf("  Insert into %s (\n",tname);
		  ll = 0;
		  for (i=1; i<=ccount; i++)
		   {
		    # Test for line length exceeded
		    if (ll+length(colname[i])+1>=maxlen)
		     {
		      printf("\n");
		      ll = 0;
		     }
		    ll += length(colname[i])+1;
		    printf("%s%s", colname[i],
		     (i==ccount)?")\n":",");
		   }
		  printf("values (\n");
		  for (i=1; i<=ccount; i++)
		   {
		    newstr = "";
		    size=getsize(type[i]);
		    if (size)
		     {
		      if (type[i] ~ "NUMBER")
		        newstr = sprintf("mod(%s, %d)", loopvar,size);
		      # The handling of "CHAR" captures char, varchar and
		      # varchar2 types
		      else if (type[i] ~ "CHAR" || type[i] ~ "RAW")
		       {
		        if (pad == "Y")
	         newstr = sprintf("lpad(substr(to_char(%s),1,%d), %d, '%s')", 
				loopvar,size,size,padchar);
			else
		 newstr = sprintf("substr(to_char(%s),1,%d)",loopvar,size);
		       }
                      else if (type[i] ~ "LOB")
		       {
		        newstr = hexstr;
		       }
                      else if (type[i] ~ "BFILE")
                       {
                        newstr = bfile_name;
		       }
                      else if (type[i] ~ "TIMESTAMP" && truncflg)
                        newstr = "trunc(sysdate)+i";
                      else if (type[i] ~ "TIMESTAMP")
                        newstr = "sysdate+i";
		     } # end if size
		    else
		     {
		      if (type[i] == "DATE" && truncflg)
			newstr = sprintf("trunc(sysdate)+i");
		      else if (type[i] == "DATE")
			newstr = sprintf("sysdate+i");
                      else if (type[i] ~ "TIMESTAMP" && truncflg)
                        newstr = "trunc(sysdate)+i";
                      else if (type[i] ~ "TIMESTAMP")
                        newstr = "sysdate+i";
                      else if (type[i] ~ "LOB")
		        newstr = hexstr;
		      else
			newstr = sprintf("%s", loopvar);
		     }

		    # Test for line length exceeded
		    if (ll+length(newstr)+1>=maxlen)
		     {
		      printf("\n%s", newstr);
		      ll = 0;
		     }
		     else
		     {
		      printf("%s", newstr);
		      ll += length(newstr);
		     }
		     printf("%s", i!=ccount?",":");\n");
		     ll++;
		    } # end loop

		  for (j=0; j<midcnt; j++)
                     printf("%s\n", midln[j]);
		 }
